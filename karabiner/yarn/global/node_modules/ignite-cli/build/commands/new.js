"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var gluegun_1 = require("gluegun");
var ramda_1 = require("ramda");
var is_ignite_directory_1 = require("../lib/is-ignite-directory");
var exit_codes_1 = require("../lib/exit-codes");
var add_empty_boilerplate_1 = require("../lib/add-empty-boilerplate");
var boilerplate_install_1 = require("../lib/boilerplate-install");
/**
 * Creates a new ignite project based on an optional boilerplate.
 */
module.exports = {
    alias: ['n'],
    description: 'Generate a new React Native project with Ignite CLI.',
    run: function command(toolbox) {
        return __awaiter(this, void 0, void 0, function () {
            var parameters, strings, print, filesystem, ignite, prompt, runtime, meta, isBlank, upperFirst, camelCase, log, projectName, projectNameCamel, overwrite, boilerplateName, boilerplates, boilerplate, originalFolder, appFolder, deepFolder, ok, deepFiles, yarnOrNPM, spinner;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parameters = toolbox.parameters, strings = toolbox.strings, print = toolbox.print, filesystem = toolbox.filesystem, ignite = toolbox.ignite, prompt = toolbox.prompt, runtime = toolbox.runtime, meta = toolbox.meta;
                        isBlank = strings.isBlank, upperFirst = strings.upperFirst, camelCase = strings.camelCase;
                        log = ignite.log;
                        projectName = (parameters.first || '').toString();
                        // verify the project name is a thing
                        if (isBlank(projectName)) {
                            print.info(runtime.brand + " new <projectName>\n");
                            print.error('Project name is required');
                            process.exit(exit_codes_1.default.PROJECT_NAME);
                        }
                        // warn if more than one argument is provided for <projectName>
                        if (parameters.second) {
                            print.info("Info: You provided more than one argument for <projectName>. The first one (" + projectName + ") will be used and the rest are ignored."); // prettier-ignore
                        }
                        // guard against `ignite new ignite`
                        if (ramda_1.toLower(projectName) === 'ignite') {
                            print.error("Hey...that's my name! Please name your project something other than '" + projectName + "'.");
                            process.exit(exit_codes_1.default.PROJECT_NAME);
                        }
                        // check for kebabs
                        if (ramda_1.not(ramda_1.isEmpty(ramda_1.match(/.-/g, "" + projectName)))) {
                            projectNameCamel = upperFirst(camelCase(projectName));
                            print.error("Please use camel case for your project name. Ex: " + projectNameCamel);
                            process.exit(exit_codes_1.default.PROJECT_NAME);
                        }
                        // check for numbers-only names
                        if (/^\d+$/.test(projectName)) {
                            print.error("Please use at least one non-numeric character for your project name.");
                            process.exit(exit_codes_1.default.PROJECT_NAME);
                        }
                        // check for alphanumeric name, beginning with a letter
                        if (!/^[a-z_][a-z0-9_]+$/i.test(projectName)) {
                            print.error("The project name can only contain alphanumeric characters and underscore, but must not begin with a number.");
                            process.exit(exit_codes_1.default.PROJECT_NAME);
                        }
                        // ensure we're in a supported directory
                        if (is_ignite_directory_1.default(process.cwd())) {
                            print.error('The `ignite new` command cannot be run within an already ignited project.');
                            process.exit(exit_codes_1.default.NOT_IGNITE_PROJECT);
                        }
                        // prevent installing when node_modules/react-native exists
                        if (filesystem.exists('node_modules/react-native')) {
                            print.error('The `ignite new` command cannot be run within a directory with `node_modules/react-native` installed.');
                            print.error('Try installing from a directory without a `node_modules` directory.');
                            process.exit(exit_codes_1.default.EXISTING_REACT_NATIVE);
                        }
                        if (!(filesystem.exists(projectName) === 'dir')) return [3 /*break*/, 3];
                        print.error("Directory " + projectName + " already exists.");
                        if (!parameters.options.overwrite) return [3 /*break*/, 1];
                        print.info("Overwriting " + projectName + "...");
                        filesystem.remove(projectName);
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, prompt.confirm('Do you want to overwrite this directory?')];
                    case 2:
                        overwrite = _a.sent();
                        if (overwrite) {
                            print.info("Overwriting " + projectName + "...");
                            filesystem.remove(projectName);
                        }
                        else {
                            process.exit(exit_codes_1.default.DIRECTORY_EXISTS);
                        }
                        _a.label = 3;
                    case 3:
                        // print a header
                        require('../brand/header')();
                        print.newline();
                        print.info("\uD83D\uDD25 igniting app " + print.colors.yellow(projectName));
                        if (!(parameters.options.boilerplate === false)) return [3 /*break*/, 5];
                        return [4 /*yield*/, add_empty_boilerplate_1.default(toolbox)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                    case 5:
                        boilerplateName = parameters.options.boilerplate || parameters.options.b;
                        // If the name starts with ., /, \, or ~, it's probably a path.
                        // Expand it so it's the full real path here.
                        if (['~', '.', '\\', '/'].includes((boilerplateName || '')[0])) {
                            boilerplateName = filesystem.path(boilerplateName);
                        }
                        boilerplates = [
                            { name: '---', message: 'Infinite Red boilerplates', value: 'sep', role: 'separator' },
                            {
                                name: 'ignite-bowser',
                                message: 'Bowser (React Navigation, MobX State Tree, & TypeScript) - RECOMMENDED',
                            },
                            { name: 'ignite-andross', message: 'Andross (React Navigation, Redux, & Redux Saga)' },
                            { name: '---', message: 'Third-party boilerplates', value: 'sep', role: 'separator' },
                            {
                                name: 'ignite-jhipster',
                                message: 'JHipster (https://github.com/ruddell/ignite-jhipster)',
                            },
                        ];
                        if (!!boilerplateName) return [3 /*break*/, 7];
                        return [4 /*yield*/, prompt.ask([
                                {
                                    name: 'boilerplate',
                                    message: 'Which boilerplate would you like to use?',
                                    type: 'select',
                                    choices: boilerplates,
                                },
                            ])];
                    case 6:
                        boilerplate = (_a.sent()).boilerplate;
                        boilerplateName = boilerplate;
                        _a.label = 7;
                    case 7:
                        // update parameters for down the stack
                        parameters.options.boilerplate = boilerplateName;
                        parameters.options.b = boilerplateName;
                        if (boilerplateName.includes('alpha') || boilerplateName.includes('beta')) {
                            print.warning("\uD83D\uDC09 You're using a prerelease version of " + boilerplateName + ".");
                        }
                        originalFolder = process.cwd();
                        appFolder = path.join(originalFolder, projectName);
                        deepFolder = path.join(originalFolder, projectName, projectName);
                        log("making directory " + appFolder);
                        filesystem.dir(appFolder);
                        process.chdir(appFolder);
                        log("switched directory to " + process.cwd());
                        // make a temporary package.json file so node stops walking up the directories
                        filesystem.write('package.json', {
                            name: 'ignite-shim',
                            description: 'A temporary package.json created to prevent node from wandering too far.',
                            repository: 'infinitered/ignite',
                            license: 'MIT',
                        });
                        return [4 /*yield*/, boilerplate_install_1.default(toolbox)];
                    case 8:
                        ok = _a.sent();
                        if (!ok) {
                            print.error('error installing boilerplate');
                            process.exit(exit_codes_1.default.GENERIC);
                        }
                        // remove the temporary node_modules
                        filesystem.remove('node_modules');
                        log("switching back to " + appFolder);
                        process.chdir(appFolder);
                        deepFiles = filesystem.list(deepFolder) || [];
                        if (parameters.options.debug)
                            console.log(deepFiles);
                        log("moving contents of " + projectName + " into place");
                        deepFiles.forEach(function (filename) {
                            log("moving " + filename);
                            filesystem.move(path.join(deepFolder, filename), path.join(appFolder, filename));
                        });
                        log("removing unused sub directory " + deepFolder);
                        filesystem.remove(deepFolder);
                        yarnOrNPM = ignite.useYarn ? 'yarn' : 'npm i';
                        spinner = print.spin("running " + yarnOrNPM + " one last time...");
                        return [4 /*yield*/, gluegun_1.system.run(yarnOrNPM)];
                    case 9:
                        _a.sent();
                        spinner.succeed(yarnOrNPM + " complete");
                        if (!(!parameters.options['skip-git'] && !filesystem.exists('./.git') && gluegun_1.system.which('git'))) return [3 /*break*/, 11];
                        spinner = print.spin('setting up source control with git');
                        return [4 /*yield*/, gluegun_1.system.run("git init . && git add -A && git commit -m \"Initial commit\nIgnite CLI version " + meta.version() + "\"")];
                    case 10:
                        _a.sent();
                        spinner.succeed("configured git");
                        _a.label = 11;
                    case 11:
                        // done
                        log('finished running new');
                        return [2 /*return*/];
                }
            });
        });
    },
};
//# sourceMappingURL=new.js.map