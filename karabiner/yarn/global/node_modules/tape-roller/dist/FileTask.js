"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const procurator_1 = require("procurator");
const fs = __importStar(require("fs"));
const util = __importStar(require("util"));
const path = __importStar(require("path"));
const debug = debug_1.default('tape-roller:FileTask');
exports.TMP_POSTFIX = '___TMP';
class FileTask {
    constructor(files, concatFileName = false, options = {}) {
        this.subjects = [];
        this.options = {};
        this.concatFileName = concatFileName;
        this.options = options;
        (!Array.isArray(files) ? [files] : files).forEach(file => this.addSubject(file));
    }
    addSubject(file) {
        debug(`Creating new task for "${file}"`);
        const filePath = this.options.cwd ? path.resolve(this.options.cwd, file) : file;
        debug(`Reading from "${filePath}"`);
        this.subjects.push({ file, stream: fs.createReadStream(filePath) });
    }
    write(destinationName) {
        const writes = this.subjects.map((subject) => this.writeFile(subject, destinationName));
        return Promise.all(writes);
    }
    async update() {
        const writes = this.subjects.map(async (subject) => {
            await this.writeFile(subject, subject.file + exports.TMP_POSTFIX);
            return util.promisify(fs.rename)(subject.file + exports.TMP_POSTFIX, subject.file);
        });
        return Promise.all(writes);
    }
    async writeFile(subject, destinationName) {
        const destination = this.concatFileName ? path.resolve(destinationName, subject.file) : destinationName;
        debug(`Creating write to ${this.concatFileName ? 'concatenated' : 'regular'} destination "${destination}".`);
        try {
            await util.promisify(fs.mkdir)(path.parse(destination).dir, { recursive: true });
        }
        catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
        const writeStream = fs.createWriteStream(destination);
        subject.stream = subject.stream.pipe(writeStream);
        return new Promise((resolve, reject) => {
            writeStream.on('error', reject);
            writeStream.on('finish', resolve);
        });
    }
    replace(parameters) {
        this.pipe(() => procurator_1.stream(parameters, true, 100));
        return this;
    }
    modify(pattern, { append, prepend, custom, replace }) {
        const transformer = (match, ...rest) => {
            if (typeof replace !== 'undefined') {
                return replace;
            }
            if (typeof append !== 'undefined') {
                return match + append;
            }
            if (typeof prepend !== 'undefined') {
                return prepend + match;
            }
            if (typeof custom === 'function') {
                return custom(match, ...rest);
            }
            return match;
        };
        this.pipe(() => procurator_1.createTransform(chunk => chunk.replace(pattern, transformer)));
        return this;
    }
    pipe(through) {
        this.subjects.forEach(subject => {
            subject.stream = subject.stream.pipe(through());
        });
        return this;
    }
}
exports.FileTask = FileTask;
//# sourceMappingURL=FileTask.js.map