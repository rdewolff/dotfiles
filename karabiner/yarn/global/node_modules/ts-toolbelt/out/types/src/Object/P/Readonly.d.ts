import { Record } from '../../Object/Record';
import { IterationOf } from '../../Iteration/IterationOf';
import { Iteration } from '../../Iteration/Iteration';
import { Pos } from '../../Iteration/Pos';
import { Next } from '../../Iteration/Next';
import { Readonly as OReadonly } from '../Readonly';
import { Last } from '../../Tuple/Last';
import { Pop } from '../../Tuple/Pop';
import { Depth } from '../_Internal';
import { Path as PPath } from './_Internal';
import { Prepend } from '../../Tuple/Prepend';
import { Index } from '../../Any/Index';
import { LastIndex } from '../../Tuple/LastIndex';
import { Tuple } from '../../Tuple/Tuple';
import { Key } from '../../Iteration/Key';
declare type _Readonly<O extends object, Path extends Tuple<Index>, K extends Index, depth extends Depth, I extends Iteration = IterationOf<'0'>> = {
    [P in keyof O]: O[P] extends infer Prop ? P extends Path[Pos<I>] ? Prop extends object ? Key<I> extends LastIndex<Path, 's'> ? OReadonly<Prop, K, depth> : _Readonly<Prop, Path, K, depth, Next<I>> : Prop : Prop : never;
} & {};
/** Make some fields of **`O`** readonly at **`Path`** (deeply or not)
 * (⚠️ this type is expensive)
 * @param O to make readonly
 * @param Path to be followed
 * @param depth to do it deeply (?=`'flat'`)
 * @returns **`object`**
 * @example
 * ```ts
 * ```
 */
export declare type Readonly<O extends object, Path extends PPath, depth extends Depth = 'flat'> = _Readonly<Record<'_', O>, Pop<Prepend<Path, '_'>>, Last<Path>, depth>['_'];
export {};
