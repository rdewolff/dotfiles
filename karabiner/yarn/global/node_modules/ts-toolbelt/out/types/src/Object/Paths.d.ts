import { Prepend } from '../Tuple/Prepend';
import { Reverse } from '../Tuple/Reverse';
import { Optional } from '../Tuple/Optional';
import { Index } from '../Any/Index';
import { NonNullable } from '../Tuple/NonNullable';
import { Concat } from '../Tuple/Concat';
import { Cast } from '../Any/Cast';
import { Equals } from '../Any/Equals';
import { True } from '../Boolean/Boolean';
import { Tuple } from '../Tuple/Tuple';
declare type _Paths<O, Paths extends Tuple<Index> = []> = {
    0: {
        [K in keyof O]: _Paths<O[K], Prepend<Paths, K>>;
    }[keyof O];
    1: NonNullable<Optional<Reverse<Paths>>>;
    2: NonNullable<Optional<Concat<Reverse<Paths>, Index[]>>>;
}[Equals<O, any> extends True ? 2 : O extends object ? [keyof O] extends [never] ? 1 : 0 : 1];
/** Get all the possible paths of **`O`**
 * (⚠️ this won't work with circular-refs)
 * @param O to be inspected
 * @returns **`string[]`**
 * @example
 * ```ts
 * ```
 */
export declare type Paths<O extends object> = _Paths<O> extends infer X ? Cast<X, Tuple<Index>> : never;
export {};
